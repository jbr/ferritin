use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    // Tell Cargo to rerun this script if the themes directory changes
    println!("cargo:rerun-if-changed=assets/themes");

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_dir = Path::new(&out_dir);

    // Build the theme set
    match build_theme_set() {
        Ok(theme_set) => {
            println!("Built theme set with {} themes", theme_set.themes.len());

            // Serialize each theme individually and generate the themes module
            generate_themes_module(&theme_set, out_dir);
        }
        Err(e) => {
            eprintln!("Warning: Failed to build theme set: {}", e);
            eprintln!("This is likely because git submodules weren't fetched.");
            eprintln!("Run: git submodule update --init --recursive");
            eprintln!("Creating empty theme set as fallback (ferritin will fail at runtime)");
            let empty_theme_set = syntect::highlighting::ThemeSet::new();
            generate_themes_module(&empty_theme_set, out_dir);
        }
    }
}

fn build_theme_set() -> Result<syntect::highlighting::ThemeSet, Box<dyn std::error::Error>> {
    use syntect::highlighting::ThemeSet;

    let mut theme_set = ThemeSet::new();
    let assets_dir = PathBuf::from("assets/themes");

    if !assets_dir.exists() {
        return Err("assets/themes directory not found".into());
    }

    // Load standalone .tmTheme files from the themes directory
    for entry in fs::read_dir(&assets_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("tmTheme") {
            match ThemeSet::get_theme(&path) {
                Ok(theme) => {
                    let theme_name = path
                        .file_stem()
                        .and_then(|s| s.to_str())
                        .unwrap_or("unknown")
                        .to_string();
                    println!("Loaded theme: {}", theme_name);
                    theme_set.themes.insert(theme_name, theme);
                }
                Err(e) => {
                    eprintln!("Warning: Failed to load theme {:?}: {}", path, e);
                }
            }
        }
    }

    // Load themes from submodule directories
    for entry in fs::read_dir(&assets_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            // Try to load all themes from this directory
            match theme_set.add_from_folder(&path) {
                Ok(()) => {
                    println!("Loaded themes from {:?}", path.file_name().unwrap());
                }
                Err(e) => {
                    eprintln!(
                        "Warning: Failed to load themes from {:?}: {}",
                        path.file_name().unwrap(),
                        e
                    );
                }
            }
        }
    }

    if theme_set.themes.is_empty() {
        return Err("No themes were loaded".into());
    }

    Ok(theme_set)
}

fn generate_themes_module(theme_set: &syntect::highlighting::ThemeSet, out_dir: &Path) {
    let themes_dir = out_dir.join("themes");
    fs::create_dir_all(&themes_dir).expect("Failed to create themes directory");

    let mut theme_names: Vec<_> = theme_set.themes.keys().cloned().collect();
    theme_names.sort();

    // Serialize each theme individually
    for (name, theme) in &theme_set.themes {
        let theme_bytes = syntect::dumps::dump_binary(theme);
        let safe_filename = name.replace(' ', "_").replace("(", "").replace(")", "");
        let theme_path = themes_dir.join(format!("{}.bin", safe_filename));
        fs::write(&theme_path, theme_bytes)
            .unwrap_or_else(|e| panic!("Failed to write theme {}: {}", name, e));
    }

    // Generate the themes.rs module
    let mut content = String::from("// Auto-generated by build.rs\n\n");
    content.push_str("use syntect::highlighting::Theme;\n\n");

    // Generate the load_theme function
    content.push_str("pub fn load_theme(name: &str) -> Option<Theme> {\n");

    if theme_names.is_empty() {
        // No themes available - just return None
        content.push_str("    None\n");
    } else {
        // Generate match expression for available themes
        content.push_str("    match name {\n");

        for name in &theme_names {
            let safe_filename = name.replace(' ', "_").replace("(", "").replace(")", "");
            content.push_str(&format!(
                "        {:?} => Some(syntect::dumps::from_binary(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/themes/{}.bin\")))),\n",
                name, safe_filename
            ));
        }

        content.push_str("        _ => None,\n");
        content.push_str("    }\n");
    }

    content.push_str("}\n\n");

    // Generate THEME_NAMES constant
    content.push_str("pub const THEME_NAMES: &[&str] = &[\n");
    for name in &theme_names {
        content.push_str(&format!("    {:?},\n", name));
    }
    content.push_str("];\n");

    let module_path = out_dir.join("themes.rs");
    fs::write(&module_path, content).expect("Failed to write themes.rs");
}
