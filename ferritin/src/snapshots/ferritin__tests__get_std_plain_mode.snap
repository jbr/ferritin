---
source: ferritin/src/tests.rs
expression: "render_for_tests(Commands::get(\"std\"), OutputMode :: Plain)"
---
Item: std
Kind: Module
Visibility: Public
Defined at: std
In crate: std (RUST_VERSION)

The Rust Standard Library
================================================================================

The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec<T> and Option<T>, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.

std is available to all Rust crates by default. Therefore, the standard library can be accessed in use statements through the path std, as in use std::env.

How to read this documentation
================================================================================

If you already know the name of what you are looking for, the fastest way to find it is to use the search button at the top of the page.

Otherwise, you may want to jump to one of these useful sections:

  ◦ std::* modules

  ◦ Primitive types

  ◦ Standard macros

  ◦ The Rust Prelude

If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!

Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the " Summary" button near the top of the page to collapse it into a more skimmable view.

While you are looking at the top of the page, also notice the "Source" link. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.

What is in the standard library documentation?
================================================================================

First of all, The Rust Standard Library is divided into a number of focused modules, all listed further down this page. These modules are the bedrock upon which all of Rust is forged, and they have mighty names like std::slice and std::cmp. Modules' documentation typically includes an overview of the module along with examples, and are a smart place to start familiarizing yourself with the library.

Second, implicit methods on primitive types are documented here. This can be a source of confusion for two reasons:

  ◦ While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are documented in the section on primitives.

  ◦ The standard library exports many modules with the same name as primitive types. These define additional items related to the primitive type, but not the all-important methods.

So for example there is a page for the primitive type char that lists all the methods that can be called on characters (very useful), and there is a page for the module std::char that documents iterator and error types created by these methods (rarely useful).

Note the documentation for the primitives str and [T] (also called 'slice'). Many method calls on String and Vec<T> are actually calls to methods on str and [T] respectively, via deref coercions.

Third, the standard library defines The Rust Prelude, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.

And finally, the standard library exports a number of standard macros, and lists them on this page (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.

Contributing changes to the documentation
================================================================================

Check out the Rust contribution guidelines here. The source for this documentation can be found on GitHub in the 'library/std/' directory. To contribute changes, make sure you read the guidelines first, then submit pull-requests for your suggested changes.

Contributions are appreciated! If you see a part of the docs that can be improved, submit a PR, or chat with us first on Zulip #docs.

A Tour of The Rust Standard Library
================================================================================

The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.

Containers and collections
--------------------------------------------------------------------------------

The option and result modules define optional and error-handling types, Option<T> and Result<T, E>. The iter module defines Rust's iterator trait, Iterator, which works with the for loop to access collections.

The standard library exposes three common ways to deal with contiguous regions of memory:

  ◦ Vec<T> - A heap-allocated vector that is resizable at runtime.

  ◦ [T; N] - An inline array with a fixed size at compile time.

  ◦ [T] - A dynamically sized slice into any other kind of contiguous storage, whether heap-allocated or not.

Slices can only be handled through some kind of pointer, and as such come in many flavors such as:

  ◦ &[T] - shared slice

  ◦ &mut [T] - mutable slice

  ◦ Box<[T]> - owned slice

str, a UTF-8 string slice, is a primitive type, and the standard library defines many methods for it. Rust strs are typically accessed as immutable references: &str. Use the owned String for building and mutating strings.

For converting to strings use the format! macro, and for converting from strings use the FromStr trait.

Data may be shared by placing it in a reference-counted box or the Rc type, and if further contained in a Cell or RefCell, may be mutated as well as shared. Likewise, in a concurrent setting it is common to pair an atomically-reference-counted box, Arc, with a Mutex to get the same effect.

The collections module defines maps, sets, linked lists and other typical collection types, including the common HashMap<K, V>.

Platform abstractions and I/O
--------------------------------------------------------------------------------

Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.

Common types of I/O, including files, TCP, and UDP, are defined in the io, fs, and net modules.

The thread module contains Rust's threading abstractions. sync contains further primitive shared memory types, including atomic, mpmc and mpsc, which contains the channel types for message passing.

Use before and after main()
================================================================================

Many parts of the standard library are expected to work before and after main(); but this is not guaranteed or ensured by tests. It is recommended that you write your own tests and run them on each platform you wish to support. This means that use of std before/after main, especially of features that interact with the OS or global state, is exempted from stability and portability guarantees and instead only provided on a best-effort basis. Nevertheless bug reports are appreciated.

On the other hand core and alloc are most likely to work in such environments with the caveat that any hookable behavior such as panics, oom handling or allocators will also depend on the compatibility of the hooks.

Some features may also behave differently outside main, e.g. stdio could become unbuffered, some panics might turn into aborts, backtraces might not get symbolicated or similar.

Non-exhaustive list of known limitations:

  ◦ after-main use of thread-locals, which also affects additional features:
      ▪     thread::current()

  ◦ under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged (they are guaranteed to be open during main, and are opened to /dev/null O_RDWR if they weren't open on program start)

Modules

  ◦ alloc 
    Memory allocation APIs. [...]

  ◦ any 
    Utilities for dynamic typing or type reflection. [...]

  ◦ arch 
    SIMD and vendor intrinsics module. [...]

  ◦ array 
    Utilities for the array primitive type. [...]

  ◦ ascii 
    Operations on ASCII strings and characters. [...]

  ◦ async_iter 
    Composable asynchronous iteration. [...]

  ◦ autodiff 
    This module provides support for automatic differentiation.

  ◦ backtrace 
    Support for capturing a stack backtrace of an OS thread [...]

  ◦ borrow 
    A module for working with borrowed data.

  ◦ boxed 
    The Box<T> type for heap allocation. [...]

  ◦ bstr 
    The ByteStr and ByteString types and trait implementations.

  ◦ cell 
    Shareable mutable containers. [...]

  ◦ char 
    Utilities for the char primitive type. [...]

  ◦ clone 
    The Clone trait for types that cannot be 'implicitly copied'. [...]

  ◦ cmp 
    Utilities for comparing and ordering values. [...]

  ◦ collections 
    Collection types. [...]

  ◦ convert 
    Traits for conversions between types. [...]

  ◦ default 
    The Default trait for types with a default value.

  ◦ env 
    Inspection and manipulation of the process's environment. [...]

  ◦ error 
    Interfaces for working with Errors. [...]

  ◦ f128 
    Constants for the f128 quadruple-precision floating point type. [...]

  ◦ f16 
    Constants for the f16 half-precision floating point type. [...]

  ◦ f32 
    Constants for the f32 single-precision floating point type. [...]

  ◦ f64 
    Constants for the f64 double-precision floating point type. [...]

  ◦ ffi 
    Utilities related to FFI bindings. [...]

  ◦ fmt 
    Utilities for formatting and printing Strings. [...]

  ◦ from 
    Unstable module containing the unstable From derive macro.

  ◦ fs 
    Filesystem manipulation operations. [...]

  ◦ future 
    Asynchronous basic functionality. [...]

  ◦ hash 
    Generic hashing support. [...]

  ◦ hint 
    Hints to compiler that affects how code should be emitted or optimized. [...]

  ◦ i128 
    Redundant constants module for the i128 primitive type. [...]

  ◦ i16 
    Redundant constants module for the i16 primitive type. [...]

  ◦ i32 
    Redundant constants module for the i32 primitive type. [...]

  ◦ i64 
    Redundant constants module for the i64 primitive type. [...]

  ◦ i8 
    Redundant constants module for the i8 primitive type. [...]

  ◦ intrinsics 
    Compiler intrinsics. [...]

  ◦ io 
    Traits, helpers, and type definitions for core I/O functionality. [...]

  ◦ isize 
    Redundant constants module for the isize primitive type. [...]

  ◦ iter 
    Composable external iteration. [...]

  ◦ marker 
    Primitive traits and types representing basic properties of types. [...]

  ◦ mem 
    Basic functions for dealing with memory. [...]

  ◦ net 
    Networking primitives for TCP/UDP communication. [...]

  ◦ num 
    Additional functionality for numerics. [...]

  ◦ ops 
    Overloadable operators. [...]

  ◦ option 
    Optional values. [...]

  ◦ os 
    OS-specific functionality.

  ◦ panic 
    Panic support in the standard library.

  ◦ pat 
    Helper module for exporting the pattern_type macro

  ◦ path 
    Cross-platform path manipulation. [...]

  ◦ pin 
    Types that pin data to a location in memory. [...]

  ◦ prelude 
    The Rust Prelude [...]

  ◦ process 
    A module for working with processes. [...]

  ◦ ptr 
    Manually manage memory through raw pointers. [...]

  ◦ random 
    Random value generation.

  ◦ range 
    Experimental replacement range types [...]

  ◦ rc 
    Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'. [...]

  ◦ result 
    Error handling with the Result type. [...]

  ◦ simd 
    Portable SIMD module. [...]

  ◦ slice 
    Utilities for the slice primitive type. [...]

  ◦ str 
    Utilities for the str primitive type. [...]

  ◦ string 
    A UTF-8–encoded, growable string. [...]

  ◦ sync 
    Useful synchronization primitives. [...]

  ◦ task 
    Types and Traits for working with asynchronous tasks.

  ◦ thread 
    Native threads. [...]

  ◦ time 
    Temporal quantification. [...]

  ◦ u128 
    Redundant constants module for the u128 primitive type. [...]

  ◦ u16 
    Redundant constants module for the u16 primitive type. [...]

  ◦ u32 
    Redundant constants module for the u32 primitive type. [...]

  ◦ u64 
    Redundant constants module for the u64 primitive type. [...]

  ◦ u8 
    Redundant constants module for the u8 primitive type. [...]

  ◦ unsafe_binder 
    Operators used to turn types into unsafe binders and back.

  ◦ usize 
    Redundant constants module for the usize primitive type. [...]

  ◦ vec 
    A contiguous growable array type with heap-allocated contents, written Vec<T>. [...]

  ◦ vec 
    A contiguous growable array type with heap-allocated contents, written Vec<T>. [...]

Macros

  ◦ format 
    Creates a String using interpolation of runtime expressions. [...]
